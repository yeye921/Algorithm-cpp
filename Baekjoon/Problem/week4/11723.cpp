// 큰돌 풀이
// 숫자를 배열을 이용해서 저장하는 것이 아니라 비트마스킹을 이용해서 하나의 숫자로 저장함
// (m이 20이니까 가짓수가 30이하임으로 비트마스킹을 적용할 수 있는 것이다)

// toggle연산: x가 들어있으면 삭제, 그렇지 않으면 삽입 (따라서 XOR연산 이용)
// XOR(^)연산: 두 비트가 같으면 0, 다르면 1 반환
// 이진법으로 출력하는법: bitset<32(몇비트)> (num);
#include <bits/stdc++.h>
using namespace std;
int n, m, x;
char s[11];
int main() {
    scanf(" %d", &m);
    for (int i = 0; i < m; i++) {
        scanf(" %s %d", &s, &x);
        if (s[0]=='a' && s[1]=='d') n |= (1 << x); // x를 n에 담음 (배열대신 비트마스킹 이용, OR연산자를 이용하기 때문에 x가 이미 들어있으면 무시됨)
        else if (s[0] == 'r') n &= ~(1 << x); // x번째 비트를 끔 (= 배열에서 x를 삭제)
        else if (s[0] == 'c') printf("%d\n", (n & (1 << x)) == 0 ? 0: 1); // x번째 비트가 켜져있는지 확인
        else if (s[0] == 't') n ^= (1 << x); // x번째 비트가 켜져있는지 확인
        else if (s[0] == 'a' && s[1] == 'l') n = (1 << 21) - 1; // all이면 모든 비트를 킴
        else n = 0;
    }
}