// Tip) 문제를 딱 봤을 때 루틴이 있어야 함 !!
// 1. 최대/최소 범위를 확인한다
// 2. 무식하게 풀 수 있는지 확인한다

// n의 배수다 = n으로 나누어 떨어진다 ex. if(val % n = 0) // n의 배수인지 체크
// n의 배수는 1로만 이루어져있다 ex. 1, 11, 111, 1111, ...

// 이 문제의 Logic
// 1. 1, 11, 111, .. 의 형태로 만듬
// 2. % n == 0 -> n의 배수가 되는지 체크
// 3. 1의 개수(자릿수) 세기

// +) 근데 1을 하고 2를 하면 오버플로 발생! ex. 111,111,111,111 % n => 따라서 모듈러 연산 이용
// 1111111을 만들고 나서 모듈러 하는 것과 만들면서 모듈러 하는 것은 동일한 결과!!

// 숫자가 너무 커지는 것을 방지하기 위해 모듈러 연산을 활용할 수 있다 !
// 즉, 111이 N으로 나눠지지 않아서 1111로 넘어갈 때, 1111을 바로 다음 반복문으로 넘기는 것이 아니라 mod N 연산을 해주고 넘기는 것이다. 그러면 숫자가 계속 커지는 것을 방지할 수 있다.

// 1로만 이루어진 수 만드는 방법
// 1, 1*10+1=11, 11*10+1=111, 111*10+1=1111, ..
#include<bits/stdc++.h>
using namespace std;  
typedef long long ll; 
int n;
int main(){ 
	while(scanf("%d", &n) != EOF){ // 입력이 계속해서 이어질 경우
		int cnt = 1, ret = 1;      // ret = 1의 개수
		while(true){
			if(cnt % n == 0){      // n의 배수인걸 찾음
				printf("%d\n", ret);
				break;
			}else{
				cnt = (cnt * 10) + 1; // 1로만 이루어진 수 만듬
				cnt %= n;             // mod 연산을 해 준 결과를 다음 반복문으로 넘김
				ret++;
			}
		}
        cout << ret << "\n"; // 목표
	}
	return 0;
} 