// 이 문제는 "짝짓기" 문제다 => stack을 이용해야함 !

// 이 문제의 시간복잡도 => 완전탐색(무식하게)으로 풀면 100만^2 = 10억 => 시간 초과남
// 알고리즘 유형: 이분탐색, 라인스위핑, 투포인터, 그리디, 펜윅트리
// 이 문제는 그리디로 풀 수 있음 (그리디: 어떤 인덱스에서 최적의 경우의 수 생각해내는 것)

// 스택을 이용한 풀이 (이 풀이를 코드로 구현해내기 어려움)
// 오큰수가 나타는 순간: num1 < num2 => stk.pop()  
// 그렇지 않은 순간(애매한 순간) => 스택에 push함

// 포인트 !!
// 1. stack에 수열의 인덱스로 담기 => 그래야 ret에 오큰수를 순서대로(인덱스대로) 저장가능
// 2. 수열의 원소를 입력받으면서 while로 반복하기 (while의 조건문이 포인트)
#include <bits/stdc++.h>
using namespace std; 
int n, a[1000004], ret[1000004]; // a: 수열의 원소를 저장하는 배열, ret: 수열 원소의 오큰수를 저장하는 배열
stack<int> s; 
int main(){
	cin >> n; 
	memset(ret, -1, sizeof(ret)); // 오큰수가 아니면 1을 리턴해야하기 때문
	for(int i = 0; i < n; i++){ // 수열의 원소 탐색
		cin >> a[i];  
		while(s.size() && a[s.top()] < a[i]){ // 오큰수가 결정되는 순간
			ret[s.top()] = a[i];
            s.pop();
		}
		s.push(i); // 그렇지 않다면 인덱스를 push
	}
	for(int i = 0; i < n; i++) cout << ret[i] << " ";  
} 