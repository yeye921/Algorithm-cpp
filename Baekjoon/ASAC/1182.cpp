// 연속된 수의 합을 찾는 것이 아니다
// 연속되는 수열이 아니라 부분 수열을 어떻게 만들지 모르겠음... 
// 모든 부분수열의 경우의 수 구하는 법 => 5C1, 5C2,...,5C5 => 정수가 n개이면 n!개의 경우 존재

// 숫자 개수가 20개이하니까 비트마스킹이 가능함
// 벡터에서 배열로 바꿨을 때, 시간이 얼마나 줄어드는지 => 4ms
#include <bits/stdc++.h>
using namespace std;
int n, s, num, ret, all[23];
vector<int> all;
int main(){
    cin >> n >> s;
    for(int i = 0; i < n; i++){
        cin >> num;
        // 이 숫자를 벡터에 넣을건지, 배열에 넣을건지..? => 배열이 탐색에 O(1)이므로 배열!
        all[i] = num;
    }
    // 1~n개를 뽑는 경우의 수를 탐색하면서 각 경우의 합이 s가 되는 개수를 출력 (개수만 구하면 되니까 굳이 따로 벡터 만들어서 넣을 필요는 없음)
    for(int i = 1; i < (1 << n); i++){ // 시간 복잡도: 2^n = 2^20, 크기가 양수인 수열이니까 1부터 시작!
        int sum = 0;
        for(int j = 0; j < n; j++){
            if(i & (1 << j)){
                sum += all[j];
            }
        }
        if(sum == s) ret++;
    }
    cout << ret << "\n";
}