// 문어박사 풀이
// 핵심로직: x를 1로 만들기위해서 노력하는게 아니라 1부터 x를 만드는데 걸리는 최소 연산수를 채워가는 것
// => dp는 이렇게 반대로 생각하거나 규칙을 찾는게 중요함

// ex. 6(즉, dp[6])을 만들 수 있는 방법
// 1. 5에서 +1 (5를 만드는 최소연산횟수(dp[5]=3) + 1(현재)))
// 2. 3에서 *2 (3를 만드는 최소연산횟수(dp[3]=1) + 1(현재)))
// 3. 2에서 *3 (2를 만드는 최소연산횟수(dp[2]=1) + 1(현재)))
// 따라서 dp[6]에는 4,2,2 중 최솟값인 2가 적힌다

// dp 테이블에는 해당 수를 만드는데 드는 최소 연산 수를 적어넣는다
// dp 테이블 만드는 방법 이해안가면 강의 참고
#include <bits/stdc++.h>
using namespace std;
int n;
int dp[110];
int main(){
    cin >> n;
    // 초기식 설정
    dp[1] = 0;

    // 반복처리하며 테이블 채움
    // dp[i]: i번째 숫자를 만드는데 필요한 최소 연산 횟수
    for(int i = 2; i <= n; i++){
        // 3개의 연산 중 Min 값 고름
        // 점화식: dp[i] = min(dp[i-1]+1, dp[i/2]+1, dp[i/3]+1)
        dp[i] = dp[i-1] + 1;
        if(i % 2 == 0) dp[i] = min(dp[i], dp[i/2]+1); // 2의 배수인 경우
        if(i % 3 == 0) dp[i] = min(dp[i], dp[i/3]+1); // 3의 배수인 경우
    }
    cout << dp[n] << "\n";
    return 0;
}